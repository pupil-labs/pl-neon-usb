{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pupil Labs Neon USB","text":"<p>Library for connecting to Neon via USB</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pupil-labs-neon-usb\n</code></pre> <p>or</p> <pre><code>pip install -e git+https://github.com/pupil-labs/pl-neon-usb.git\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Pupil Labs GmbH\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"modules/","title":"API reference","text":""},{"location":"modules/#pupil_labs.neon_usb","title":"neon_usb","text":"<p>pupil_labs.neon_usb package.</p> <p>Library for connecting to Neon via USB</p> <p>Modules:</p> <ul> <li> <code>cameras</code>           \u2013            </li> <li> <code>frame</code>           \u2013            </li> <li> <code>pyrav4l2</code>           \u2013            </li> <li> <code>queue_utils</code>           \u2013            </li> <li> <code>usb_utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>EyeCamera</code>           \u2013            <p>Provides an interface for handling the Neon eye cameras.</p> </li> <li> <code>Frame</code>           \u2013            </li> <li> <code>SceneCamera</code>           \u2013            <p>Provides an interface for handling the Neon scene camera.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_all_items</code>             \u2013              <p>Retrieve all items from a queue and always at least one.</p> </li> </ul>"},{"location":"modules/#pupil_labs.neon_usb.EyeCamera","title":"EyeCamera","text":"<pre><code>EyeCamera(spec: CameraSpec = NEON_EYE_CAMERA_SPEC)\n</code></pre> <p>               Bases: <code>Camera</code></p> <p>Provides an interface for handling the Neon eye cameras.</p> <p>The class is assuming that no more than one Neon device is connected to the computer at the same time.</p> <p>Note that the two eye cameras is Neon are treated as a single device. Grabbing a frame from the <code>EyeCam</code> class will return a single frame containing images from both cameras.</p> <p>The camera stream will be started right away. If the object fails to grab frames, it will automatically try to reinitialize.</p> Source code in <code>src/pupil_labs/neon_usb/cameras/eye.py</code> <pre><code>def __init__(self, spec: CameraSpec = NEON_EYE_CAMERA_SPEC) -&gt; None:\n    \"\"\"Initialize the eye cameras of the connected Neon device.\n\n    The camera stream will be started right away. If the object fails to grab\n    frames, it will automatically try to reinitialize.\n    \"\"\"\n    super().__init__(spec, V4l2Backend)\n    self.exposure_algorithm: Exposure_Time | None = Exposure_Time(\n        max_ET=28, frame_rate=200, mode=\"auto\"\n    )\n</code></pre>"},{"location":"modules/#pupil_labs.neon_usb.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(img: ndarray, timestamp: float, index: int)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>bgr</code>               (<code>ndarray</code>)           \u2013            <p>Return a 3-channel BGR version of self.img</p> </li> <li> <code>gray</code>               (<code>ndarray</code>)           \u2013            <p>Return a grayscale version of self.img</p> </li> </ul>"},{"location":"modules/#pupil_labs.neon_usb.Frame.bgr","title":"bgr  <code>property</code>","text":"<pre><code>bgr: ndarray\n</code></pre> <p>Return a 3-channel BGR version of self.img</p>"},{"location":"modules/#pupil_labs.neon_usb.Frame.gray","title":"gray  <code>property</code>","text":"<pre><code>gray: ndarray\n</code></pre> <p>Return a grayscale version of self.img</p>"},{"location":"modules/#pupil_labs.neon_usb.SceneCamera","title":"SceneCamera","text":"<pre><code>SceneCamera(spec: CameraSpec = NEON_SCENE_CAMERA_SPEC)\n</code></pre> <p>               Bases: <code>Camera</code></p> <p>Provides an interface for handling the Neon scene camera.</p> <p>The class is assuming that no more than one Neon device is connected to the computer at the same time.</p> <p>The camera stream will be started right away. If the object fails to grab frames, it will automatically try to reinitialize.</p> <p>Methods:</p> <ul> <li> <code>get_intrinsics</code>             \u2013              <p>Retrieve the scene camera intrinsics of the Neon device</p> </li> </ul> Source code in <code>src/pupil_labs/neon_usb/cameras/scene.py</code> <pre><code>def __init__(self, spec: CameraSpec = NEON_SCENE_CAMERA_SPEC) -&gt; None:\n    \"\"\"Initialize the scene camera of the connected Neon device.\n\n    The camera stream will be started right away. If the object fails to grab\n    frames, it will automatically try to reinitialize.\n    \"\"\"\n    super().__init__(NEON_SCENE_CAMERA_SPEC, UVCBackend)\n\n    assert isinstance(self.backend, UVCBackend)\n    self.uvc_controls = {\n        c.display_name: c for c in self.backend._uvc_capture.controls\n    }\n    camera_parameters = {\n        \"Backlight Compensation\": 2,\n        \"Brightness\": 0,\n        \"Contrast\": 32,\n        \"Gain\": 64,\n        \"Hue\": 0,\n        \"Saturation\": 64,\n        \"Sharpness\": 50,\n        \"Gamma\": 300,\n        \"Auto Exposure Mode\": 1,\n        \"Absolute Exposure Time\": 250,\n    }\n    for key, value in camera_parameters.items():\n        try:\n            self.uvc_controls[key].value = value\n        except KeyError:\n            print(f\"Setting {key} to {value} failed: Unknown control. Known \")\n</code></pre>"},{"location":"modules/#pupil_labs.neon_usb.SceneCamera.get_intrinsics","title":"get_intrinsics  <code>staticmethod</code>","text":"<pre><code>get_intrinsics() -&gt; SceneIntrinsics\n</code></pre> <p>Retrieve the scene camera intrinsics of the Neon device</p> <p>Returns:</p> <ul> <li> <code>SceneIntrinsics</code>           \u2013            <p>Tuple containing camera matrix and distortion coefficients of scene camera.</p> </li> </ul> Source code in <code>src/pupil_labs/neon_usb/cameras/scene.py</code> <pre><code>@staticmethod\ndef get_intrinsics() -&gt; SceneIntrinsics:\n    \"\"\"Retrieve the scene camera intrinsics of the Neon device\n\n    Returns:\n        Tuple containing camera matrix and distortion coefficients of scene camera.\n\n    \"\"\"\n    calib_data = get_calibration()\n    return SceneIntrinsics(\n        calib_data.scene_camera_matrix,\n        calib_data.scene_distortion_coefficients,\n        calib_data.scene_extrinsics_affine_matrix,\n    )\n</code></pre>"},{"location":"modules/#pupil_labs.neon_usb.get_all_items","title":"get_all_items","text":"<pre><code>get_all_items(q: Queue[T]) -&gt; list[T]\n</code></pre> <p>Retrieve all items from a queue and always at least one.</p> Source code in <code>src/pupil_labs/neon_usb/queue_utils.py</code> <pre><code>def get_all_items(q: queue.Queue[T]) -&gt; list[T]:\n    \"\"\"Retrieve all items from a queue and always at least one.\"\"\"\n    items = []\n    # Need to get at least one item\n    # Otherwise the queue might be spammed with requests\n    items.append(q.get())\n    while True:\n        try:\n            items.append(q.get_nowait())\n        except queue.Empty:\n            break\n    return items\n</code></pre>"},{"location":"coverage/","title":"Coverage","text":""}]}