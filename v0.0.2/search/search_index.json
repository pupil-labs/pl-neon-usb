{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pupil Labs Neon USB","text":"<p>Library for connecting to Neon via USB</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pupil-labs-neon-usb\n</code></pre> <p>or</p> <pre><code>pip install -e git+https://github.com/pupil-labs/pl-neon-usb.git\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Pupil Labs GmbH\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"modules/","title":"API reference","text":""},{"location":"modules/#pupil_labs.neon_usb","title":"neon_usb","text":"<p>pupil_labs.neon_usb package.</p> <p>Library for connecting to Neon via USB</p> <p>Modules:</p> <ul> <li> <code>cameras</code>           \u2013            </li> <li> <code>frame</code>           \u2013            </li> <li> <code>pyrav4l2</code>           \u2013            </li> <li> <code>queue_utils</code>           \u2013            </li> <li> <code>usb_utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Frame</code>           \u2013            </li> <li> <code>IMU</code>           \u2013            <p>Cython wrapper for Neon USB IMU device.</p> </li> <li> <code>IMUData</code>           \u2013            <p>Data from the Inertial Measurement Unit (IMU).</p> </li> <li> <code>SceneCamera</code>           \u2013            <p>Provides an interface for handling the Neon scene camera.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_all_items</code>             \u2013              <p>Retrieve all items from a queue and always at least one.</p> </li> </ul>"},{"location":"modules/#pupil_labs.neon_usb.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(img: ndarray, timestamp: float, index: int)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>bgr</code>               (<code>ndarray</code>)           \u2013            <p>Return a 3-channel BGR version of self.img</p> </li> <li> <code>gray</code>               (<code>ndarray</code>)           \u2013            <p>Return a grayscale version of self.img</p> </li> </ul>"},{"location":"modules/#pupil_labs.neon_usb.Frame.bgr","title":"bgr  <code>property</code>","text":"<pre><code>bgr: ndarray\n</code></pre> <p>Return a 3-channel BGR version of self.img</p>"},{"location":"modules/#pupil_labs.neon_usb.Frame.gray","title":"gray  <code>property</code>","text":"<pre><code>gray: ndarray\n</code></pre> <p>Return a grayscale version of self.img</p>"},{"location":"modules/#pupil_labs.neon_usb.IMU","title":"IMU","text":"<pre><code>IMU(*args, **kwargs)\n</code></pre> <p>Cython wrapper for Neon USB IMU device.</p> <p>Methods:</p> <ul> <li> <code>get_imu_data</code>             \u2013              <p>Get the latest IMU data from the device.</p> </li> <li> <code>start_sensors</code>             \u2013              <p>Start the IMU sensors.</p> </li> <li> <code>stop_sensors</code>             \u2013              <p>Stop the IMU sensors.</p> </li> </ul>"},{"location":"modules/#pupil_labs.neon_usb.IMU.get_imu_data","title":"get_imu_data  <code>method descriptor</code>","text":"<pre><code>get_imu_data() -&gt; IMUData\n</code></pre> <p>Get the latest IMU data from the device.</p>"},{"location":"modules/#pupil_labs.neon_usb.IMU.start_sensors","title":"start_sensors  <code>method descriptor</code>","text":"<pre><code>start_sensors() -&gt; None\n</code></pre> <p>Start the IMU sensors.</p>"},{"location":"modules/#pupil_labs.neon_usb.IMU.stop_sensors","title":"stop_sensors  <code>method descriptor</code>","text":"<pre><code>stop_sensors() -&gt; None\n</code></pre> <p>Stop the IMU sensors.</p>"},{"location":"modules/#pupil_labs.neon_usb.IMUData","title":"IMUData","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Data from the Inertial Measurement Unit (IMU).</p> <p>Contains gyroscope, accelerometer, and rotation data from the IMU sensor.</p> <p>Attributes:</p> <ul> <li> <code>accel_data</code>               (<code>Data3D</code>)           \u2013            <p>Accelerometer data in m/s\u00b2.</p> </li> <li> <code>datetime</code>               (<code>datetime</code>)           \u2013            <p>Get timestamp as a datetime object.</p> </li> <li> <code>gyro_data</code>               (<code>Data3D</code>)           \u2013            <p>Gyroscope data in deg/s.</p> </li> <li> <code>quaternion</code>               (<code>Quaternion</code>)           \u2013            <p>Rotation represented as a quaternion.</p> </li> <li> <code>timestamp_unix_ns</code>               (<code>int</code>)           \u2013            <p>Get timestamp in nanoseconds since Unix epoch.</p> </li> <li> <code>timestamp_unix_seconds</code>               (<code>float</code>)           \u2013            <p>Timestamp in seconds since Unix epoch.</p> </li> </ul>"},{"location":"modules/#pupil_labs.neon_usb.IMUData.accel_data","title":"accel_data  <code>instance-attribute</code>","text":"<pre><code>accel_data: Data3D\n</code></pre> <p>Accelerometer data in m/s\u00b2.</p>"},{"location":"modules/#pupil_labs.neon_usb.IMUData.datetime","title":"datetime  <code>property</code>","text":"<pre><code>datetime: datetime\n</code></pre> <p>Get timestamp as a datetime object.</p>"},{"location":"modules/#pupil_labs.neon_usb.IMUData.gyro_data","title":"gyro_data  <code>instance-attribute</code>","text":"<pre><code>gyro_data: Data3D\n</code></pre> <p>Gyroscope data in deg/s.</p>"},{"location":"modules/#pupil_labs.neon_usb.IMUData.quaternion","title":"quaternion  <code>instance-attribute</code>","text":"<pre><code>quaternion: Quaternion\n</code></pre> <p>Rotation represented as a quaternion.</p>"},{"location":"modules/#pupil_labs.neon_usb.IMUData.timestamp_unix_ns","title":"timestamp_unix_ns  <code>property</code>","text":"<pre><code>timestamp_unix_ns: int\n</code></pre> <p>Get timestamp in nanoseconds since Unix epoch.</p>"},{"location":"modules/#pupil_labs.neon_usb.IMUData.timestamp_unix_seconds","title":"timestamp_unix_seconds  <code>instance-attribute</code>","text":"<pre><code>timestamp_unix_seconds: float\n</code></pre> <p>Timestamp in seconds since Unix epoch.</p>"},{"location":"modules/#pupil_labs.neon_usb.SceneCamera","title":"SceneCamera","text":"<pre><code>SceneCamera(spec: CameraSpec = NEON_SCENE_CAMERA_SPEC)\n</code></pre> <p>               Bases: <code>Camera</code></p> <p>Provides an interface for handling the Neon scene camera.</p> <p>The class is assuming that no more than one Neon device is connected to the computer at the same time.</p> <p>The camera stream will be started right away. If the object fails to grab frames, it will automatically try to reinitialize.</p> <p>Methods:</p> <ul> <li> <code>get_intrinsics</code>             \u2013              <p>Retrieve the scene camera intrinsics of the Neon device</p> </li> </ul> Source code in <code>src/pupil_labs/neon_usb/cameras/scene.py</code> <pre><code>def __init__(self, spec: CameraSpec = NEON_SCENE_CAMERA_SPEC) -&gt; None:\n    \"\"\"Initialize the scene camera of the connected Neon device.\n\n    The camera stream will be started right away. If the object fails to grab\n    frames, it will automatically try to reinitialize.\n    \"\"\"\n    super().__init__(NEON_SCENE_CAMERA_SPEC, UVCBackend)\n\n    assert isinstance(self.backend, UVCBackend)\n    self.uvc_controls = {\n        c.display_name: c for c in self.backend._uvc_capture.controls\n    }\n    camera_parameters = {\n        \"Backlight Compensation\": 2,\n        \"Brightness\": 0,\n        \"Contrast\": 32,\n        \"Gain\": 64,\n        \"Hue\": 0,\n        \"Saturation\": 64,\n        \"Sharpness\": 50,\n        \"Gamma\": 300,\n        \"Auto Exposure Mode\": 1,\n        \"Absolute Exposure Time\": 250,\n    }\n    for key, value in camera_parameters.items():\n        try:\n            self.uvc_controls[key].value = value\n        except KeyError:\n            print(f\"Setting {key} to {value} failed: Unknown control. Known \")\n</code></pre>"},{"location":"modules/#pupil_labs.neon_usb.SceneCamera.get_intrinsics","title":"get_intrinsics  <code>staticmethod</code>","text":"<pre><code>get_intrinsics() -&gt; SceneIntrinsics\n</code></pre> <p>Retrieve the scene camera intrinsics of the Neon device</p> <p>Returns:</p> <ul> <li> <code>SceneIntrinsics</code>           \u2013            <p>Tuple containing camera matrix and distortion coefficients of scene camera.</p> </li> </ul> Source code in <code>src/pupil_labs/neon_usb/cameras/scene.py</code> <pre><code>@staticmethod\ndef get_intrinsics() -&gt; SceneIntrinsics:\n    \"\"\"Retrieve the scene camera intrinsics of the Neon device\n\n    Returns:\n        Tuple containing camera matrix and distortion coefficients of scene camera.\n\n    \"\"\"\n    calib_data = get_calibration()\n    return SceneIntrinsics(\n        calib_data.scene_camera_matrix,\n        calib_data.scene_distortion_coefficients,\n        calib_data.scene_extrinsics_affine_matrix,\n    )\n</code></pre>"},{"location":"modules/#pupil_labs.neon_usb.get_all_items","title":"get_all_items","text":"<pre><code>get_all_items(q: Queue[T]) -&gt; list[T]\n</code></pre> <p>Retrieve all items from a queue and always at least one.</p> Source code in <code>src/pupil_labs/neon_usb/queue_utils.py</code> <pre><code>def get_all_items(q: queue.Queue[T]) -&gt; list[T]:\n    \"\"\"Retrieve all items from a queue and always at least one.\"\"\"\n    items = []\n    # Need to get at least one item\n    # Otherwise the queue might be spammed with requests\n    items.append(q.get())\n    while True:\n        try:\n            items.append(q.get_nowait())\n        except queue.Empty:\n            break\n    return items\n</code></pre>"},{"location":"coverage/","title":"Coverage","text":""},{"location":"generated_examples/collection_speed_both_cameras/","title":"Collection Speed Both Cameras","text":"<pre><code>import queue\nimport time\nfrom threading import Event, Thread\n\nfrom tqdm import tqdm\n\nfrom pupil_labs.neon_usb import (\n    EyeCameraUVC,\n    Frame,\n    SceneCamera,\n    get_all_items,\n    image_receiver,\n)\n\neye_start_event = Event()\neye_stop_event = Event()\nscene_start_event = Event()\nscene_stop_event = Event()\n\neye_q = queue.Queue[Frame](maxsize=400)\neye_thread = Thread(\n    target=image_receiver,\n    args=(EyeCameraUVC, eye_q, eye_start_event, eye_stop_event, scene_start_event),\n)\neye_thread.start()\n\n\nscene_q = queue.Queue[Frame](maxsize=400)\nscene_thread = Thread(\n    target=image_receiver,\n    args=(SceneCamera, scene_q, scene_start_event, scene_stop_event, eye_start_event),\n)\nscene_thread.start()\n\neye_start_event.wait()\nscene_start_event.wait()\n\n\ntotal_eye_frames = 5000\neye_frame_counter = 0\nscene_frame_counter = 0\nwith tqdm(total=total_eye_frames) as pbar:\n    start = time.time()\n    while True:\n        if eye_frame_counter &gt;= total_eye_frames:\n            break\n        eye_frames = get_all_items(eye_q)\n        num_eye_frames = len(eye_frames)\n        eye_frame_counter += num_eye_frames\n\n        scene_frames = get_all_items(scene_q)\n        num_scene_frames = len(scene_frames)\n        scene_frame_counter += num_scene_frames\n\n        pbar.update(num_eye_frames)\n\nend = time.time()\neye_stop_event.set()\nscene_stop_event.set()\nprint(\n    \"\\t\".join([\n        f\"Eye FPS: {eye_frame_counter / (end - start):.1f}\",\n        f\"Scene FPS: {scene_frame_counter / (end - start):.1f}\",\n        f\"Duration: {end - start:.1f}\",\n    ])\n)\n</code></pre>"},{"location":"generated_examples/collection_speed_eye_camera/","title":"Collection Speed Eye Camera","text":"<pre><code>import queue\nimport time\nfrom threading import Event, Thread\n\nfrom tqdm import tqdm\n\nfrom pupil_labs.neon_usb import EyeCameraUVC, Frame, get_all_items, image_receiver\n\neye_start_signal = Event()\neye_stop_signal = Event()\neye_q = queue.Queue[Frame](maxsize=400)\neye_thread = Thread(\n    target=image_receiver,\n    args=(EyeCameraUVC, eye_q, eye_start_signal, eye_stop_signal),\n)\neye_thread.start()\neye_start_signal.wait()\n\n\ntotal_frames = 500\nframe_counter = 0\nwith tqdm(total=total_frames) as pbar:\n    start = time.time()\n    while True:\n        if frame_counter &gt;= total_frames:\n            break\n\n        eye_frames = get_all_items(eye_q)\n        num_eye_frames = len(eye_frames)\n        frame_counter += num_eye_frames\n\n        pbar.update(num_eye_frames)\n\nend = time.time()\neye_stop_signal.set()\nprint(f\"Eye FPS: {frame_counter / (end - start):.1f} \\t Duration: {end - start:.1f}\")\n\n# eye_cam = EyeCam()\n# num_frames = 5000\n# start = time.time()\n# for i in tqdm(range(num_frames)):\n#     eye_frame = eye_cam.get_frame()\n# end = time.time()\n# print(f\"FPS: {num_frames / (end - start):.1f}\")\n</code></pre>"},{"location":"generated_examples/collection_speed_imu/","title":"Collection Speed Imu","text":"<pre><code>import contextlib\nimport queue\nimport time\nfrom threading import Event, Thread\nfrom typing import TypeVar\n\nfrom tqdm import tqdm\n\nfrom pupil_labs.neon_usb import IMU, IMUData\n\nT = TypeVar(\"T\")\n\n\ndef get_all_items(q: queue.Queue[T]) -&gt; list[T]:\n    \"\"\"Retrieve all items from a queue and always at least one.\"\"\"\n    items = []\n    # Need to get at least one item\n    # Otherwise the queue might be spammed with requests\n    items.append(q.get())\n    while True:\n        try:\n            items.append(q.get_nowait())\n        except queue.Empty:\n            break\n    return items\n\n\ndef imu_receiver(\n    output_q: queue.Queue[IMUData],\n    start_event: Event,\n    stop_event: Event,\n    wait_event: Event | None = None,\n) -&gt; None:\n    imu = IMU()\n    start_event.set()\n    if wait_event is not None:\n        wait_event.wait()\n    while True:\n        if stop_event.is_set():\n            break\n        imu_data = imu.get_imu_data()\n        with contextlib.suppress(queue.Full):\n            output_q.put_nowait(imu_data)\n\n\nimu_start_signal = Event()\nimu_stop_signal = Event()\nimu_q = queue.Queue[IMUData](maxsize=400)\nimu_thread = Thread(\n    target=imu_receiver,\n    args=(imu_q, imu_start_signal, imu_stop_signal),\n)\nimu_thread.start()\nimu_start_signal.wait()\n\n\ntotal_frames = 500\nframe_counter = 0\nwith tqdm(total=total_frames) as pbar:\n    start = time.time()\n    while True:\n        if frame_counter &gt;= total_frames:\n            break\n\n        imu_frames = get_all_items(imu_q)\n        num_imu_frames = len(imu_frames)\n        frame_counter += num_imu_frames\n\n        pbar.update(num_imu_frames)\n\nend = time.time()\nimu_stop_signal.set()\nprint(f\"IMU FPS: {frame_counter / (end - start):.1f} \\t Duration: {end - start:.1f}\")\n</code></pre>"},{"location":"generated_examples/imu/","title":"Imu","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.animation import FuncAnimation\n\nfrom pupil_labs.neon_usb import IMU\n\n\ndef quaternion_to_rotation_matrix(q):\n    \"\"\"Convert quaternion to rotation matrix.\"\"\"\n    # Handle Quaternion object with x, y, z, w attributes\n    if hasattr(q, \"x\") and hasattr(q, \"y\") and hasattr(q, \"z\") and hasattr(q, \"w\"):\n        x, y, z, w = q.x, q.y, q.z, q.w\n    elif len(q) == 4:\n        w, x, y, z = q\n    else:\n        raise ValueError(f\"Expected quaternion with 4 elements, got {len(q)}\")\n\n    # Normalize quaternion\n    norm = np.sqrt(w**2 + x**2 + y**2 + z**2)\n    if norm == 0:\n        return np.eye(3)\n    w, x, y, z = w / norm, x / norm, y / norm, z / norm\n\n    # Calculate rotation matrix\n    R = np.array([\n        [1 - 2 * (y**2 + z**2), 2 * (x * y - w * z), 2 * (x * z + w * y)],\n        [2 * (x * y + w * z), 1 - 2 * (x**2 + z**2), 2 * (y * z - w * x)],\n        [2 * (x * z - w * y), 2 * (y * z + w * x), 1 - 2 * (x**2 + y**2)],\n    ])\n\n    return R\n\n\ndef main():\n    # Initialize IMU\n    imu = IMU()\n\n    # Set up the figure and 3D axis\n    fig = plt.figure(figsize=(10, 8))\n    ax = fig.add_subplot(111, projection=\"3d\")\n\n    # Create device axes\n    device_axes = {\n        \"x\": np.array([[0, 2], [0, 0], [0, 0]]),\n        \"y\": np.array([[0, 0], [0, 2], [0, 0]]),\n        \"z\": np.array([[0, 0], [0, 0], [0, 2]]),\n    }\n\n    # Set up the plot\n    ax.set_xlim([-5, 5])\n    ax.set_ylim([-5, 5])\n    ax.set_zlim([-5, 5])\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_zlabel(\"Z\")\n    ax.set_title(\"Orientation Visualization\")\n\n    # reference axes\n    ax.plot([0, 3], [0, 0], [0, 0], \"r-\", alpha=0.3, linewidth=1)\n    ax.plot([0, 0], [0, 3], [0, 0], \"g-\", alpha=0.3, linewidth=1)\n    ax.plot([0, 0], [0, 0], [0, 3], \"b-\", alpha=0.3, linewidth=1)\n\n    # device axes\n    device_lines = {}\n    colors = {\"x\": \"red\", \"y\": \"green\", \"z\": \"blue\"}\n    for axis_name, axis_coords in device_axes.items():\n        (line,) = ax.plot(*axis_coords, color=colors[axis_name], linewidth=3, alpha=1.0)\n        device_lines[axis_name] = line\n\n    def update(frame):\n        # Get IMU data\n        try:\n            imu_datum = imu.get_imu_data()\n            quaternion = imu_datum.quaternion\n\n            # Convert quaternion to rotation matrix\n            R = quaternion_to_rotation_matrix(quaternion)\n\n            # Update existing device axes lines instead of recreating them\n            for axis_name, axis_coords in device_axes.items():\n                # axis_coords has shape (3, 2), transpose to (2, 3) for rotation\n                rotated_axis = (axis_coords.T @ R.T).T\n                device_lines[axis_name].set_data_3d(*rotated_axis)\n\n        except Exception as e:\n            print(f\"Error reading IMU data: {e}\")\n\n    # Create animation\n    _ = FuncAnimation(fig, update, interval=10, blit=False)\n\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"generated_examples/manual_exposure_eye_uvc/","title":"Manual Exposure Eye Uvc","text":"<pre><code>import time\n\nimport cv2\n\nfrom pupil_labs.neon_usb.cameras.eye import EyeCameraUVC\n\ncamera = EyeCameraUVC()\n\ncounter = 0\nwhile True:\n    counter += 1\n    frame = camera.get_frame()\n    image = frame.bgr\n    print(\"exposure:\", camera.exposure)\n    camera.exposure = (counter % 50, (counter * 2) % 50)\n    cv2.imshow(\"Neon Sensor Module\", image)\n    cv2.waitKey(1)\n    time.sleep(0.05)\n</code></pre>"},{"location":"generated_examples/manual_exposure_eye_v4l2/","title":"Manual Exposure Eye V4L2","text":"<pre><code>import time\n\nimport cv2\n\nfrom pupil_labs.neon_usb.cameras.eye import EyeCameraV4l2\n\ncamera = EyeCameraV4l2()\n\ncounter = 0\nwhile True:\n    counter += 1\n    frame = camera.get_frame()\n    image = frame.bgr\n    print(\"exposure:\", camera.exposure)\n    camera.exposure = (counter % 50, (counter * 2) % 50)\n    cv2.imshow(\"Neon Sensor Module\", image)\n    cv2.waitKey(1)\n    time.sleep(0.05)\n</code></pre>"},{"location":"generated_examples/manual_exposure_scene/","title":"Manual Exposure Scene","text":"<pre><code>import cv2\n\nfrom pupil_labs.neon_usb import SceneCamera\n\ncamera = SceneCamera()\n\ncounter = 0\nwhile True:\n    counter += 1\n    print(camera.exposure)\n    frame = camera.get_frame()\n    image = frame.bgr\n    camera.exposure = 50 + (counter % 125) * 10\n    cv2.imshow(\"Neon Scene Camera\", image)\n    cv2.waitKey(1)\n</code></pre>"},{"location":"generated_examples/real-time_visualization/","title":"Real-Time Visualization","text":"<pre><code>import cv2\n\nfrom pupil_labs.neon_usb import EyeCameraUVC, SceneCamera\n\nscene_cam = SceneCamera()\neye_cam = EyeCameraUVC()\n\n\nwhile True:\n    print(\"frame\")\n    scene_frame = scene_cam.get_frame()\n    eye_frame = eye_cam.get_frame()\n\n    cv2.imshow(\"Neon Eye Camera\", eye_frame.gray)\n    cv2.imshow(\"Neon Scene Camera\", scene_frame.bgr)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == 27:\n        break\n\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"generated_examples/reconnecting/","title":"Reconnecting","text":"<pre><code>from pupil_labs.neon_usb import CameraNotFoundError, EyeCameraUVC, SceneCamera\n\nscene_cam = SceneCamera()\neye_cam = EyeCameraUVC()\n\n# Disconnect Neon while running this code to see the reconnection in action\nwhile True:\n    try:\n        scene_frame = scene_cam.get_frame()\n        eye_frame = eye_cam.get_frame()\n    except TimeoutError:\n        print(\n            \"\\nTimeoutError - The device has been disconnected.\"\n            \" Attempting to reconnect.\\n\"\n        )\n        attempts = 0\n        while True:\n            try:\n                # del eye_cam # When adding this line, the execution will freeze here\n                scene_cam = SceneCamera()\n                print(\"This gets printed.\")\n                eye_cam = EyeCameraUVC()\n                print(\"This never gets printed.\")\n            except CameraNotFoundError:\n                attempts += 1\n                print(\"\\033[1A\", end=\"\\x1b[2K\")  # This line clears the previous line\n                print(f\"Device not yet reconnected. Retrying...{attempts}\")\n            else:\n                print(\"Device reconnected.\\n\")\n                break\n        continue\n\n    print(f\"\\rscene index: {scene_frame.index} \\t eye index: {eye_frame.index}\", end=\"\")\n</code></pre>"}]}